<h1> System Design of URL Shortener</h1>

Credits - https://www.youtube.com/watch?v=C7_--hAhiaM | Shreyansh Jain

- It is a tool that converts a long URL into a shorter one, making it easier to share, especially in platforms with character limits.
- It's beneficial for social media, text messages, or any situation where brevity is important.


![image](https://github.com/user-attachments/assets/cdee4899-dc52-4410-8635-5401b89e283e)

- An API that takes a long URL via a POST request, converts it to a short URL, stores both in a database, and returns the short URL. 
- The database table will have columns for the original long URL and the generated short URL.

Reuirement Analysis :

- How short url we want ? for that we need to do
- traffic analysis .
- e.g - 10 million urls per day.
- 3650 million urls per day  and I want to continue the service for 100 years .
- So we have to manage to create around 3650 x 100 Million urls ~ 365 billion urls.

- SO we can use a-z ,A-Z and 0-9 characters to use = 62 characters
- With one character we can generate 62 strings , 2 characters  ~ 62^2 . 3 characters ~ 62^3.
- similarly , 62^6 ~ (56 Billion) and 62^7 ~ (3.5 trillion)
- To be able to support atleast 365 billion urls we would need 7 characters .


- Next , how to generate this 7 characters ?

- So , These 7 characters would be hash values that will be generated by passing a hash function on long url .
- how to generate this hash values ?

- 2 methods for that - hash function and Base62 encoding


Hash Function - 
MD5 , SHA1.

- Can we use it - Let's see.

- MD5
- It is a 128 bit hash function , meaning it will generate a 128 bit hash result of hexadecimals if given the long url.
- Now , 128 bits means 16 bytes and it requires 4 bits to represent a single hexadecimal character (0-9, A,B,C,D,E,F).
- Therefore means in 8bits(1byte) - 2 hexadecimal characters .
- SO in 16bytes - 32 hexadecimal characters.
- But our requirment was to make it as short as we can , which came up to 7 characters . Therefore this is not fulfilling our needs.

- SHA1
- It is a 160 bit hash function so will generate 40 characters length , for the same reason we cannot choose this too.


- Even if it generated mroe than 7 characters , we can trim all the remaining character after 7 , right ? But this can result to duplicacy .
- Different urls generated hash codes wmight be different after 7 characters which when trimmed would lead to collisons.

Base62 encoding

![image](https://github.com/user-attachments/assets/52fc6d42-a7f5-43bd-a9f6-6aaf86be7c1e)

- We know any decimal number(base10) can be converted to any base . WE want to convert decimal to base 62 as we need 62 characters.

starting from 0 - 9 , a(10) - z , A-Z(61)

![image](https://github.com/user-attachments/assets/8d5ccfd1-1d14-4576-9772-b553e47abadd)


For example to convert 1000 to base 62 .

![image](https://github.com/user-attachments/assets/b0734d12-f2cc-4dbb-b0f1-c72613439596)

SO , g is represented as 16 therefore , 1000 --> g8 in base 62.


- We now can convert a number to base62 string
- now the problem is we need ID(number) , which can be converted to base62 unique id .

- Now we would be needing a ID generator which should always create unique number .

- The url shortener service when requests the ID generator , to make sure the response of ID generator is always unique we have following methods.

- Counter-Based (Redis)

- Maintain a global counter that increments with each new URL generated.
- This counter ensures that each ID is unique.
- When the counter increments, we convert the number returned to Base62, which reduces the size of the URL.

- Limitations:
- The counter is centralized, so scaling this solution requires more work and it will be single point of failure .

- To solve single source of failure , what if we create multiple instances of counter server .
- Then the same problem - we need to take care of syncronisation between them so that no two server generate the same ID.

-Solution (without synchronization)- 
- What is we assign different ranges to different servers so that each server will generate number within their range .
- In order to assign and manage different ranges to those distributed counter servers - we need Apache Zookeper .

![image](https://github.com/user-attachments/assets/e2ad75ad-80b6-49d6-a0d9-61df3c71820f)

- Each worker thread will be alloted different ranges .
- If one counter server exhausts all its range (e.g 1M to 2million), then the next unused million range lets say we have divided range upto 12M to all counter nodes then [13M - 14M] range will get assigned to that server.

- **Thus we get unique id in distributed environments**

- Another issue : length generated could be different . 
- Lets say - id generated is 16 , then converted to base62  ~ 'g'. but we needed 7 characters .

- So we do padding , with '==' so , it will be something like g====== .

- Now over both the issue is solved .

- Our final short url system design would look like -

![image](https://github.com/user-attachments/assets/1c1ab790-dca9-455d-907d-ae8a45686d44)


- The shorten urls will then get stored in the DB against the long url .

- In order to get long url when passed a short url , we will do a get call and search in the db , if short url present we will return the actual url present.

